model TheWorld is "where all things happen"
	domain Cooking is "pleasurable and rewarding"
		subsystem MicrowaveOven is "the quickest way to cook a pie"
			class Oven is
				attribute Voltage "voltage" is numeric;
				attribute Power "power" is numeric;
				attribute Capacity "capacity" is numeric;
				attribute remainingCookingTime is numeric;

				event genesis;
				event startCooking;
				event cancelCooking;
				event cookingPeriodOver;
				event beepingOver;
				event cookingPeriod carries (period is objref);
				event ovenSafe;
				
				
				behaviour is 
					state AwaitingCookingRequest is {
						remainingCookingTime := 0;
			//			beeper := select one from instances of Beeper where (Oven (related to Beeper across R1));
						generate stopBeeping to beeper;
					} end;
					
					state AssigningCookingPeriod is {
						remainingCookingtime := cookingPeriod.period;
					} end;
					
					state SignallingCookingPeriodOver is {
			//			beeper := select one from instances of Beeper where (Oven (related to Beeper across R1));
						generate startBeeping to myBeeper;
			//			light := select one from instances of Light where (Oven (related to Light across R6));
						generate switchOff to light;
			//			turntable := select one from instances of Turntable where (Oven (related to Turntable across R2));
						generate stop to turntable;
			///			magnetron := select one from instances of Magnetron where (Oven (related to Magnetron across R3));
						generate powerOff to magnetron;
					} end;
					
					state CookingSuspended is {
						remainingCookingTime := ovenTimer.timeRemaining;
						cancel cookingPeriodOver to self;
			//			light := select one from instances of Light where (Oven (related to Light across R6));
						generate switchOff to light;
			//			turntable := select one from instances of Turntable where (Oven (related to Turntable across R2));
						generate stop to turntable;
			//			magnetron := select one from instances of Magnetron where (Oven (related to Magnetron across R3));
						generate powerOff to magnetron;
					} end;
					
					state EnsuringSafeToCook is {
						if(remainingCookingTime /= 0){
			//				door := select one from instances of Door where (Oven (related to Door across R4));
							if (door.closed){
								generate ovenSafe to self;
							}
						}
					} end;
					
					state Cooking is {
						generate cookingPeriodOver to self with delay remainingCookingTime;
                        //                      light := select one from instances of Light where (Oven (related to Light across R6));
						generate switchOn to light;
			//			turntable := select one from instances of Turntable where (Oven (related to Turntable across R2));
						generate start to turntable;
			//			magnetron := select one from instances of Magnetron where (Oven (related to Magnetron across R3));
						generate powerOn to magnetron;
					} end;
				
					on genesis transition from Creation to AwaitingCookingRequest;
					on cookingPeriod transition from AwaitingCookingRequest to AssigningCookingPeriod;
					on startCooking transition from AssigningCookingPeriod to EnsuringSafeToCook;
					on startCooking transition from EnsuringSafeToCook to EnsuringSafeToCook;
					on startCooking transition from CookingSuspended to EnsuringSafeToCook;
					on cancelCooking transition from CookingSuspended to AwaitingCookingRequest;
					on cancelCooking transition from Cooking to CookingSuspended;
					on cookingPeriodOver transition from Cooking to SignallingCookingPeriodOver;
					on beepingOver transition from SignallingCookingPeriodOver to AwaitingCookingRequest;
					on ovenSafe transition from EnsuringSafeToCook to Cooking;
				end behaviour;
				
			end Oven;
				
			class Door is
				attribute closed "user is safe when door is closed" is boolean;
				event genesis;
				event release;
				event close;
				behaviour is
					state Open "The door is open" is{
						closed := false;
			//			oven := select one from instances of Oven where (Door (related to Oven across R4));
						generate cancelCooking to oven;
						}
					end Open;
					
					state Closed "The door is close" is {
						closed := true;
						}
					end Closed;
					
					on genesis transition from Creation to Closed;
					on release transition from Closed to Open;
					on close transition from Open to Closed;
				end behaviour;
			end Door;
			
			class Magnetron is
				event genesis;
				event PowerOn;
				event PowerOff;
				behaviour is
					state On "The magnetron is turned on" is {
						print "magnetron, transform!!!";
						}
					end On;
					state Off "The magnetron is turned off" is {
						print "magnetron off";
						}
					end Off;

					on genesis transition from Creation to Off;
					on PowerOn transition from Off to On;
					on PowerOff transition from On to Off;
				end behaviour;
			end Magnetron;

			class Turntable is
				attribute Size "size" is numeric;
				event genesis;
				event spin;
				event stop;
				behaviour is
					state Stationary "turn plate motor off" is {
						print "there is not a season to turn turn turn";
						}
					end;
					
					state Rotating "turn plate motor on" is {
						print "turn turn turn";
						}
					end;
					on genesis transition from Creation to Stationary;
					on spin transition from Stationary to Rotating;
					on stop transition from Rotating to Stationary;
				end behaviour;
			end Turntable;

			class Light is
				event genesis;
				event switchOn;
				event switchOff;
				behaviour is
					state LightOff "turn light off" is {
						print "light off";
						}
					end;
					
					state LightOn "turn light on" is {
						print "light on";
						}
					end;
					on genesis transition from Creation to LightOff;
					on switchOn transition from LightOff to LightOn;
					on switchOff transition from LightOn to LightOff;
				end behaviour;
			end Light;


			class Beeper is
				attribute beepCount "type" is numeric;
				event genesis;
				event beepOver;
				event pauseOver;
				event startBeeping;
				event stopBeeping;
				event beepingStopped;

				behaviour is
					state AwaitingBeeperRequest is {
						beepCount := 0;
					}
					end;

					state Beeping "turn beeper on" is {
						if(beepCount < 4) {
							print "beep beep";
							generate beppOver to self with delay 500;
						}
						else {
							generate beepingStopped to self;
			//			oven := select one from instances of Oven where (Beeper (related to Oven across R1));
							generate beepingOven to Oven;
						}
						
						beepCount := beepCount + 1;
					}
					end;

					state Pause "stop beeping!" is {
						print "no beep";
						generate pauseOver to self with delay 500;
					}
					end;
					
					on genesis transition from Creation to AwaitingBeeperRequest;
					on startBeeping transition from AwaitingBeeperRequest to Beeping;
					on stopBeeping transition from Beeping to AwaitingBeeperRequest ;
					on stopBeeping transition from Pause to AwaitingBeeperRequest ;
					on beepOver transition from Beeping to Pause;
					on pauseOver transition from Pause to Beeping;
					on beepingStopped transition from Beeping to AwaitingBeeperRequest;
				end behaviour;
			end Beeper;
			
			association R1 is "a record of the fact that each Oven has a Beeper" 
				Oven "has" 1..1 Beeper;
				Beeper "indicates completion of cooking by " 1..1 Oven;
			end R1;
			
			association R2 is "a record of the fact that each Oven has a Turntable" 
				Oven "has" 1..1 Turntable;
				Turntable "rotates food cooking by " 1..1 Oven;
			end R2;
			
			association R3 is "a record of the fact that each Oven has a Magnetron"
				Oven "has" 1..1 Magnetron;
				Magnetron "shoots electrons at the food" 1..1 Oven;
			end R3;
			
			association R4 is "a record of the fact that each Oven has a Door"
				Oven "has" 1..1 Door;
				Door "closes the entrance to" 1..1 Oven;
			end R4;
			
			association R5 is "a record of the fact that each Oven has a Light"
				Oven "has" 1..1 Light;
				Light "illuminates the cooking process" 1..1 Oven;
			end R5;
			
		end MicrowaveOven;	


		scenario CookAPie is {
			objref sharehouseOven;
			objref sharehouseBeeper;
			objref sharehouseLight;
			objref sharehouseTurntable;
			objref sharehouseDoor;
			objref sharehouseMagnetron;
				
			sharehouseOven := create Oven;
			sharehouseBeeper := create Beeper;
			sharehouseLight := create Light;
			sharehouseTurntable := create Turntable;
			sharehouseDoor := create Door;
			sharehouseMagnetron := create Magnetron;
				
			relate sharehouseOven to sharehouseBeeper across R1/*."beeps it up"*/;
			relate sharehouseOven to sharehouseLight across R5/*."lights it up"*/;
			relate sharehouseOven to sharehouseTurntable across R2/*."mixes it up"*/;
			relate sharehouseOven to sharehouseDoor across R4/*."opens it up"*/;
			relate sharehouseOven to sharehouseMagnetron across R3/*."heats it up"*/;
			
			generate cookingPeriod to sharehouseOven;	
				
	end Cooking;
end TheWorld;
