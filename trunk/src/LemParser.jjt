/*
* $Revision$
* $Log$
* Revision 1.17  2005/05/25 02:32:45  u3957053
* Rolled DomainIdentifier and DomainEndIdentifier into Identifier.
*
* Implement domain end identifier checking
*
*/

options {
    STATIC = false;
    LOOKAHEAD = 4;
    FORCE_LA_CHECK = true;
    VISITOR = true;
    MULTI = true;
    NODE_USES_PARSER=true;
	NODE_PREFIX = "LEM";
	NODE_PACKAGE = "parser";
    VISITOR_EXCEPTION = "metamodel.LemException";
}

PARSER_BEGIN(LemParser)
package parser;

import metamodel.*;
import verifier.*;
import util.*;
import java.io.*;


/**
 * LEM, a Language for Executable Models. 
 * <p>
 * This file is part of the author's Master by Coursework project. The project involves developing a
 * a text-based language to define xtUML models together with a language parser and validator. The
 * latter is a JAVA program which parses the LEM input file (according to the formal grammar) and builds
 * an in-memory graph representing the xtUML model defined by the LEM input file. This software is 
 * designed to form the basis of a suite of Open Source tools supporting xtUML.
 * <p>
 * Copyright (c) 2004, Steven Ring; steven@southsky.com.au.<br>All rights reserved pending release
 * under a suitable Open Source license.
 * <p>
 * <h2>Acknowledgements</h2>
 * <ol>
 * <li>Emma Margaret Walker, <i>A language for the specificatio of Shlaer-Mellor object-oriented
 * analysis models</i><br>ANU, BSEng Honours thesis, November 2002 </li>
 * <li>Leon Starr, <i>Metamodel for xtUML, 2002;</i> upon which much of the JAVA object model is based</li>
 * <li>Shayne Flint, instrumental in providing ongoing support and direction</li>
 * </ol>
 *
 *
 * <p>
 * Usage:<br>
 * <pre>
 * java Lem modelFile
 * </pre>
 *
 * @author  Steven Ring
 */
public class LemParser {

    private static final String id = "$Id$";
    private static final String revision = "$Revision$";
    private static final String release = "Release_1";

    /**
     * Return the id string for the parser
     *
     * @return the id string for the parser
     */
    public static String getId() {
        return id;
    }

    /**
     * Return the revision string for the parser
     *
     * @return the revision string for the parser
     */
    public static String getRevision() {
        return revision;
    }

    /**
     * Return the release string for the parser
     *
     * @return the release string for the parser
     */
    public static String getRelease() {
        return release;
    }

    /**
     * Return a parsed model based on the LEM input stream supplied to the constructor
     *
     * @return the model as an instatiated graph of metamodel object instances
     * @throws Throwable in the event of an error. A ParseException is thrown
     * if parsing fails, a LemException is thrown if the model fails is semantic
     * checking fails. Any Throwable may be thrown in the event of a program bug (this
     * is a "work in progress" after all!)
     */
     public Model parse() throws ParseException, LemException {

        Model model = null;
        Visitor visitor = null;
        
        
        // parse the input file to generate a parse tree
        // (exceptions at this point are fatal)
            
        LEMModelDeclaration md = this.ModelDeclaration();

        // Allow the ModelBuilder to build an in-memory object graph
        // representing the structure of the xtUML model

        model = new Model();

        // pass 1

        visitor = new BuilderPass1();
        md.jjtAccept(visitor, model);

        // pass 2

        visitor = new BuilderPass2( visitor.getMapper() );
        md.jjtAccept(visitor, model);

        // pass 3

        visitor = new BuilderPass3( visitor.getMapper() );
        md.jjtAccept(visitor, model);

        // return the constructed model

        return model;
    }
}

PARSER_END(LemParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : /* LITERALS */
{
 
  < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < REAL_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ARBITRARY_ID: "arbitrary_id" >
| < BOOLEAN: "boolean" >
| < DATE: "date" >
| < INTEGER: "integer" >
| < REAL: "real" >
| < STRING: "string">
| < TIMESTAMP: "timestamp" >
| < UNIQUE_ID: "unique_id" >
| < ARRAY: "array">

}


TOKEN : /* IDENTIFIERS */
{
  <ASSOCIATION: "association">
| <GENERALISATION: "generalisation">
| <SPECIALISATION: "specialisation">
| <ATTRIBUTE: "attribute">
| <END: "end">
| <BETWEEN: "between">
| <BRIDGE: "bridge">
| <OBJECT: "object">
| <IS: "is">
| <OR: "or">
| <DOMAIN: "domain">
| <SUBSYSTEM: "subsystem">
| <MODEL: "model">
| <TYPE: "type">
| <STATE: "state">
| <TRANSITION: "transition">
| <EVENT: "event">
| <BEHAVIOUR: "behaviour">
| <TO: "to">
| <FROM: "from">
| <BY: "by">
| <AT: "at">
| <ON: "on">
| <NULL: "null">
| <CARRIES: "carries">
| <CREATION: "creation">
| <DELETION: "deletion">
| <RANGE: "range">
| <PATTERN: "pattern" >
| <NUMERIC: "numeric" >
| <UNITS: "units" >
| <LENGTH: "length" >
| <PRECISION: "precision" >
| <REFERS: "refers" >
| <ACTIVE: "active" > /* x */
| <PASSIVE: "passive" > /* x */
| <CALCULATION: "calculation" >
| <DERIVED: "derived" >
| <REFERENTIAL: "referential" >
| <IDENTIFIER: "identifier" >
| <SEMI: ";">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <LPAREN: "(">
| <RPAREN: ")">
| <COMMA: ",">
| <COLON: ":">
| <DOT: ".">
| <RIGHT_ARROW: "->">
| <IS_ASSIGNED: ":=">
| <EQUAL: "=" >
|	<NE:		"/="	>
|	<LT:		"<"	>
|	<LE:		"<="	>
|	<GT:		">"	>
|	<GE:		">="	>
|	<PLUS:		"+"	>
|	<DASH:		"-"	>
|	<AMPERSAND:	"&"	>
|	<STAR:		"*"	>
|	<SLASH:		"/"	>
|	<EXPON:		"^"	>
| <WITH: "with">
| <UNIQUE : "unique">
| <LBRACE : "{">
| <RBRACE : "}">
}

TOKEN: /* ACTION LANGUAGE IDENTIFIERS */
{
  <ABS: "abs">
| <REM: "rem">
| <MOD: "mod">
| <AND: "and">
| <NOT: "not">
| <XOR: "xor">
| <TRUE: "true">
| <FALSE: "false">
| <SELF: "self">
| <GENERATE: "generate">
| <DELAY: "delay">
| <CANCEL: "cancel">
| <RELATED: "related">
| <RELATE: "relate">
| <UNRELATE: "unrelate">
| <WHERE: "where">
| <THAT: "that">
| <RELATES: "relates">
| <ACROSS: "across">
| <INSTANCES: "instances">
| <INSTANCE: "instance">
| <OF: "of">
| <ONE: "one">
| <MANY: "many">
| <ANY: "any">
| <SET: "set">
| <SELECT: "select">
| <CREATING: "creating">
| <CREATE: "create">
| <RECLASSIFY: "reclassify">
| <DELETE: "delete">
| <FOR: "for">
| <EACH: "each">
| <WHILE: "while">
| <IN: "in">
| <IF: "if">
| <ELSE: "else">
| <ELSEIF: "elseif">
}

/* Simple identifier is a catch-all, goes last */
TOKEN: /* SIMPLE IDENTIFIER */
{
  < SIMPLE_IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
| < #LETTER: ["_","a"-"z","A"-"Z"] >
| < #UPPER_LETTER: ["A" - "Z"] >
| < #LOWER_LETTER: ["a" - "z"] >
| < #DIGIT: ["0"-"9"] >
}

/* <h1>LEM language specification $Revision$ ($Name$)</h1>

 
 */
LEMModelDeclaration ModelDeclaration() : { 
// constraint: LEM_E_01001=The <identifier> at the end of a model, subsystem, domain or class block must match the <identifier> at the beginning of the block.
}
{
  <MODEL> Identifier() <IS> Description() ModelBody() EndIdentifier() <SEMI> 
  { return jjtThis; }
}

void Identifier() : {}
{
	<SIMPLE_IDENTIFIER>
}

void EndIdentifier() : {}
{
	<END> [ Identifier() ]
}

/* Documentation for Model Body */
void ModelBody() : {}
{
  ( DomainDeclaration() )+ ( BridgeDeclaration() )*
}

void BridgeDeclaration() : {
// constraint: LEM_E_01001
}
{
  <BRIDGE> BridgeIdentifier() <IS>
		  Description()
		  BridgeBody() 
  <END> [BridgeEndIdentifier()] <SEMI>
}


void BridgeBody() : {
// constraint: LEM_E_01002=<DomainIdentifier>s in <BridgeBody> must be distinct. You cannot bridge a domain to itself.
// constraint: LEM_E_01003=Each domain in a in a <BridgeBody> must be previously defined.
}
{
  <BETWEEN> Identifier() <AND> Identifier() Description()
}

void BridgeIdentifier() : {} {
  <SIMPLE_IDENTIFIER> 
}
void BridgeEndIdentifier() : {} {
  <SIMPLE_IDENTIFIER> 
}

void IdentifierDeclaration() : {}
{
        <IDENTIFIER> Description() <IS> 
             IdentifyingAttribute() [("," IdentifyingAttribute())* <AND> IdentifyingAttribute()]  
        <SEMI>
}

void IdentifyingAttribute() : {} {
  <SIMPLE_IDENTIFIER> 
}

void AttributeDeclaration() : {}
{
       
       ( BaseAttribute() | ReferentialAttribute() | DerivedAttribute() )
}

void BaseAttribute() : {}
{
	<ATTRIBUTE> AttributeIdentifier() 
	Description()
         <IS> (PrimitiveType() | DomainSpecificType()) 
	[ <IS_ASSIGNED> Literal() ]
	<SEMI>
}

void ReferentialAttribute() : {}
{
        <REFERENTIAL> <ATTRIBUTE> AttributeIdentifier() 
	Description()
         <REFERS> <TO> AttributeReference()
	<SEMI>
}


void DerivedAttribute() : {}
{
        <DERIVED> <ATTRIBUTE> AttributeIdentifier() 
	Description()
         <IS> (PrimitiveType() | DomainSpecificType())
         <CALCULATION> <IS> 
            AttributeCalculationProcedure()
         <END> <CALCULATION>
	<SEMI>
}

void AttributeCalculationProcedure() : {}
{ 	Procedure() }

void ReferredClass() : {} {
  <SIMPLE_IDENTIFIER> 
}

void ReferredAttribute() : {} {
  <SIMPLE_IDENTIFIER> 
}

void ReferredAssociation() : {} {
  <SIMPLE_IDENTIFIER> 
}

void AttributeReference() : {}
{
    [ <ACTIVE> | <PASSIVE> ] ReferredClass() <DOT> ReferredAttribute() <ACROSS> ReferredAssociation()
}

void Literal() : {} 
{  	
/*
 * TODO: EnumerationMember() here would cause ambiguous grammar.
 * Must resolve in a builder pass when we have more context.
 */

		<DECIMAL_LITERAL> 
	| 	<REAL_LITERAL> 
	| 	<STRING_LITERAL> 
	| 	BooleanLiteral() 
	|	<FLOATING_POINT_LITERAL>
	|	<NULL>
}

void AttributeIdentifier() : {}
{ <SIMPLE_IDENTIFIER> }


void DomainSpecificType() : {}
{ <SIMPLE_IDENTIFIER> }

void DomainDeclaration() : {
// constraint: LEM_E_01004=Each domain must have a unique <DomainIdentifier>.
}
{
  <DOMAIN> Identifier() <IS> 
  	Description() 
  	( TypeDeclaration() )* 
  	( SubSystemDeclaration() )+ 
  EndIdentifier() <SEMI>
}

void TypeDeclaration() : {
// constraint: LEM_E_01005=Each <TypeIdentifer> must be unique within the domain.
}
{ 
	<TYPE> TypeIdentifier()
	Description()
	<IS> TypeSpecification()
	<SEMI>
}

void PrimitiveType() : {}
{ "arbitrary_id" | "numeric" | "string" | "boolean" | "date" }

void TypeSpecification() : {}
{
	(   ArbitraryIdTypeSpecification() 
	  | EnumeratedList() 
	  | BooleanTypeSpecification() 
	  | NumericTypeSpecification() 
	  | StringTypeSpecification() 
          | DateTypeSpecification()
	)
}

void StringTypeSpecification() : {}
{
	<STRING> [ LengthSpec() ] [ PatternSpec() ]
}

void DateTypeSpecification() : {}
{
	<DATE> 
}

void BooleanTypeSpecification() : {}
{
	<BOOLEAN>
}

void ArbitraryIdTypeSpecification() : {}
{
	<ARBITRARY_ID>
}

void LengthSpec() : {}
{
	<LENGTH> <COLON> <DECIMAL_LITERAL>
}

void PatternSpec() : {}
{
	<PATTERN> <COLON> <STRING_LITERAL>
}



void NumericTypeSpecification() : {}
{
	<NUMERIC> ( UnitsSpec() )? ( RangeSpec() )? ( PrecisionSpec() )?
}

void UnitsSpec() : {}
{
	<UNITS> <COLON> <STRING_LITERAL>
}

void RangeSpec() : {

// constraint: LowRangeValue() and/or HighRangeValue() is required
// constraint: LowRangeValue() must be less that HighRangeValue() where both are specified

}
{
	<RANGE> <COLON> 
			<LBRACKET>
				[ LowRangeValue() ]  <COMMA>  [ HighRangeValue() ] 
			<RBRACKET>
}

void LowRangeValue() : {}
{
	SimpleExpression()
}

void HighRangeValue() : {}
{
	SimpleExpression()
}


void PrecisionSpec() : {}
{
	<PRECISION> <COLON> PrecisionValue()
}

void PrecisionValue() : {}
{
	<REAL_LITERAL> | <DECIMAL_LITERAL>
}

void EnumeratedList() : {}
{	"(" EnumerationMember() ("," EnumerationMember())* <OR> EnumerationMember()  ")"
}

void EnumerationMember() : {
}
{	<SIMPLE_IDENTIFIER> } 


void BooleanLiteral() : {}
{ 
	<TRUE> | <FALSE>
}

void TypeIdentifier() : {}
{ <SIMPLE_IDENTIFIER> }

/*
    @TODO - subsystems are currently specified as mandatory. They should define an <b>optional</b>
            grouping of domain elements. One approach is to have a Domain automatically declare a
            <b>Default</b> subsystem to act if the modeller omits a specific subsystem.
            
*/

void SubSystemDeclaration() : {
// constraint: LEM_E_01004=Each subsystem must have a unique <SubSystemIdentifier>
// constraint: LEM_E_01001
}
{ 
	<SUBSYSTEM> SubSystemIdentifier() <IS>
		Description() 
		SubSystemBody() 
	<END> [SubSystemEndIdentifier()] <SEMI>
}

void SubSystemIdentifier() : {}
{ <SIMPLE_IDENTIFIER> }

void SubSystemEndIdentifier() : {}
{ <SIMPLE_IDENTIFIER> }

void Description() : {}
{ [<STRING_LITERAL>] }

/*
    @TODO - check elsewhere that we have at least one class specified
*/

void SubSystemBody() : {}
{ ( ClassDeclaration() | Relationship() )* }

void ClassDeclaration() : {}
{ 
	<OBJECT> ClassIdentifier() 
                [<SPECIALISATION> <OF> SpecialisationList() ]
                <IS>
		Description()
		ClassBody() 
	<END> [ClassEndIdentifier()] <SEMI>
}

void SpecialisationList() : {}
{
    SuperClassIdentifier() ( "," SuperClassIdentifier() )* ( <AND> SuperClassIdentifier() )? 
}


void ClassEndIdentifier() : {}
{ <SIMPLE_IDENTIFIER> }

void ClassIdentifier() : {
// constraint: LEM_E_01013=Duplicate class identifier. Each class must be unique within a domain
}
{ <SIMPLE_IDENTIFIER> }


/*
<h2>RELATIONSHIPS</h2>
<hr>
*/

void Relationship() : {}
{
    ( Association() | Generalisation() )
}

/*

Example :

    Association R1 is "relationship between a Publisher and a Book"
        Publisher "produces and markets" 0..* Book;
        Book "is produced and marketed by" 1..1 Publisher;
    End R1;

@TODO - Improvements in readability could be achieved without loss of syntactic precision:

    Association R1 "represents publishing arrangements in respect of books."
        A Publisher "produces and markets" many Book;
        A Book "is produced and marketed by" one Publisher;
    End R1;

@TODO - It would be nice if we could cast the object noun to its plural form...
        
        A Publisher "produces and markets" many Books;
    
*/
void Association() :
{
// constraint: LEM_E_01016=Each relationship must have a unique ID within the domain
// constraint: LEM_E_01021=In an association, the active subject of each perspective must be the same class.
// constraint: LEM_E_01022=In an association, the active object of each perspective must be the same class.
}
{
	<ASSOCIATION> RelationshipIdentifier() <IS> 
		Description() 
        ActivePerspective() ";"
        PassivePerspective() ";"
        [ AssociationClassDeclaration() ]
	<END> [RelationshipEndIdentifier()] ";"
}

void ActivePerspective() : {
// constraint: LEM_E_01017=In an association, the subject of an active perspective must be a class defined in the domain.
// constraint: LEM_E_01018=In an association, the object of an active perspective must be a class defined in the domain.
}
{ ActiveSubject() ActiveVerbClause() Multiplicity() ActiveObject() }

void PassivePerspective() : {
// constraint: LEM_E_01019=In an association, the subject of an passive perspective must be a class defined in the domain.
// constraint: LEM_E_01020=In an association, the object of an passive perspective must be a class defined in the domain.
}
{ ActiveObject() ActiveVerbClause() Multiplicity() ActiveSubject() }

void ActiveSubject() : {}
{ <SIMPLE_IDENTIFIER> }

void ActiveObject() : {}
{ <SIMPLE_IDENTIFIER> }

void ActiveVerbClause() : {}
{ VerbClause() }

void PassiveVerbClause() : {}
{ VerbClause() }

void VerbClause() : {}
{ <STRING_LITERAL> }

/*
void ClassBody() : {}
{
	( AttributeDeclaration() )*
	( EventDeclaration() )*
	( StateDeclaration() )*
	( TransitionDeclaration() )*
}


   Consider declaring the behaviour of a class in a distinct block. 
   This alters the syntax of ClassBody() to ...
*/

void ClassBody() : {}
{
	( AttributeDeclaration() )*
        ( IdentifierDeclaration() )*
	( EventDeclaration() )*
	[ Behaviour() ]
}


void Behaviour() : {}
{
	<BEHAVIOUR> <IS>
		Description()
		( SelfEventDeclaration() )*
		( StateDeclaration() )*
		( TransitionDeclaration() )*
	<END> <BEHAVIOUR> <SEMI>
}

void SelfEventDeclaration() : {}
{
    EventDeclaration()
}

/*
	Note that it allows for the declaration of SelfEvents  which are
	private to the Behaviour block (i.e. not part of the class' public Events

*/


void Generalisation() : {
//constraint: LEM_E_01016=Each relationship must have a unique ID within the domain
}
{
	<GENERALISATION> RelationshipIdentifier() <IS>
		Description() 
        GeneralisationBody() 
	<END> [RelationshipEndIdentifier()] ";"
}

/*
    @TODO - the term "is a" is preferable to "is" ...
*/
void GeneralisationBody() : {}
{
	SuperClassIdentifier() "is" 
		SubClassIdentifier() ( "," SubClassIdentifier() )* "or" SubClassIdentifier()  ";"
}

void RelationshipIdentifier() : {}
{ <SIMPLE_IDENTIFIER> }

void RelationshipEndIdentifier() : {}
{ <SIMPLE_IDENTIFIER> }

void SuperClassIdentifier() : {
// constraint:LEM_E_01014=The superclass in a generalisation relationship must be an existing class defined in the current domain
}
{ <SIMPLE_IDENTIFIER> }

void SubClassIdentifier() : {
// constraint:LEM_E_01015=All subclasses in a generalisation relationship must be existing classes defined in the current domain
}
{ <SIMPLE_IDENTIFIER> }

void AssociationClassDeclaration() : {}
{ ClassDeclaration() }

/*

@TODO - think about using natural language phrases to represent multiplicities:

    "1..1"  -> one
    "0..1"  -> zero or one
    "0..*"  -> many
    "1..*"  -> at least one

*/
void Multiplicity() : {}
{ ( "1..1" | "0..1" | "0..*" | "1..*" ) }



/***********************************************************************************
 * Event declarations
 ***********************************************************************************/

void EventDeclaration() : {}
{
	[ <SELF> ] <EVENT> EventIdentifier() 
		Description() 
		[ <CARRIES> EventSignature()] <SEMI>
}

/*

   We may need:

void SelfEventDeclaration() : {}
{
	EventDeclaration()
}

*/

void EventIdentifier() : {
// constraint: LEM_E_01007=Duplicate event identifier. %1% is already defined. Each event must be unique within a specialisation tree.
}
{ <SIMPLE_IDENTIFIER> }


void StateSignature() : {}
{ Signature() }

void EventSignature() : {}
{ Signature() }

void Signature() : {}
{ "(" ParameterDeclaration() ( "," ParameterDeclaration() )* ")" }

void ParameterDeclaration() : {
// constraint: LEM_E_01023=In a parameter declaration, the domain specific data type must be defined in the domain
}
{ 	ParameterIdentifier() Description() <IS> (PrimitiveType() | DomainSpecificType()) }

void ParameterIdentifier() : {
// constraint: LEM_E_01008=Duplicate parameter identifier. Each parameter must be unique within a signature.
}
{ <SIMPLE_IDENTIFIER> }

/****************************************************************************************
 * State declarations
 ****************************************************************************************/

void StateDeclaration() : {}
{
    [<DELETION>] <STATE> StateIdentifier()
		Description() 
		[StateSignature()] <IS>
        StateProcedureDeclaration() 
    <END> [ StateEndIdentifier() ] ";"
}

void StateIdentifier() : {
// constraint: LEM_E_01009=Duplicate state identifier. Each state must be unique within a behaviour block.
}
{ <SIMPLE_IDENTIFIER> }

void StateEndIdentifier() : {}
{ <SIMPLE_IDENTIFIER> }

/*****************************************************************************************
 * State transition definitions
 *****************************************************************************************/

void StateProcedureDeclaration() : {}
{ 	Procedure() }

void Procedure() : {}
{ 	( Action() <SEMI> )* }

void TransitionDeclaration() : {}
{ 	
	<ON> TransitionEventIdentifier()
		Description()
		<TRANSITION> 
		<FROM> [ <CREATION> <STATE> | FromStateIdentifier() ]
		<TO> ToStateIdentifier() <SEMI>
}

void FromStateIdentifier() : {
// constraint: LEM_E_01010=Transition 'from' State must be defined in enclosing behaviour block.
// constraint: LEM_E_01012=Transition 'from' State must be a non deletion state.
}
{ <SIMPLE_IDENTIFIER> }

void ToStateIdentifier() : {
// constraint: LEM_E_01011=Transition 'to' State must be defined in enclosing behaviour block.
}
{ <SIMPLE_IDENTIFIER> }

void TransitionEventIdentifier() : {}
{ <SIMPLE_IDENTIFIER> }

/*****************************************************************************************
 * Action Language defined here
 *****************************************************************************************/


void InstanceReference() : {}
{
   <SIMPLE_IDENTIFIER>
}


void Action() : {}
{
   ObjectManipulation()
|  AttributeAssignment()    /* This should include local variable assignment */
}

void ObjectManipulation() : {}
{
( ObjectCreation() | ObjectDeletion() /*| ReadAttributes() | WriteAttributes()*/ ) 
}

/* TODO: InstanceReference -> ObjectReference */
void ObjectCreation() : {}  
{
	InstanceReference() <IS_ASSIGNED> 
		<CREATE> [<UNIQUE>] ClassIdentifier() /*  [<WITH> AttributeAssignment()] */
/*	InstanceReference() <IS_ASSIGNED> 
		<CREATE> <UNIQUE> ClassIdentifier()  [<WITH>  AttributeAssignment() ] */
}	

void AttributeAssignment() : {}
{
	(AttributeInstanceReference() <IS_ASSIGNED> Expression() )  /* (<COMMA> <SIMPLE_IDENTIFIER> <IS_ASSIGNED> Literal() )* */
}


void ObjectDeletion() : {}
{
/*	(<DELETE><SIMPLE_IDENTIFIER> <WHERE> ) | */
	(<DELETE> ObjectReference() ) 
/*	(<DELETE> [<LBRACE>] <SIMPLE_IDENTIFIER> [<RBRACE>] ) */
}

/**
 * Expressions 
 */

/**
 * AttributeInstanceReference covers local variables within a context,
 * attributes of an object.
 */
void AttributeInstanceReference() : {}
{ [ ObjectReference() "." ] AttributeIdentifier() }

void ObjectReference() : {}
{ 	"self" | <SIMPLE_IDENTIFIER> }


void Expression() : {}
{ 
	Relation()
	(	(	<AND>
		|	<OR> 
		|	<XOR>
		)
		Relation()
	)*
}

void Relation() :
{}
{
	SimpleExpression()
	( Relational() SimpleExpression() )?
}
                 
void Relational() :
{}
{
	<EQUAL>
|	<NE>
|	<LT>
|	<LE>
|	<GT>
|	<GE>
}

void SimpleExpression() :
{}
{
	Unary() Term()
|	Term() ( Adding() Term() )*
}

void Unary() :
{}
{
	<PLUS>
|	<DASH>
}

void Adding() :
{}
{
	<PLUS>
|	<DASH>
|	<AMPERSAND>
}

void Term() :
{}
{
	Factor() ( Multiplying() Factor() )*
}

void Multiplying() :
{}
{
	<STAR>
|	<SLASH>
|	<MOD>
|	<REM>
}

void Factor() :
{}
{
	Primary() ( <EXPON> Primary() )?
|	<NOT> Primary()
|	<ABS> Primary()
}

void Primary() :
{}
{
	Literal()
|	AttributeInstanceReference()
|	ParenthesizedPrimary()
}

void ParenthesizedPrimary() :
{}
{
	<LPAREN>
	Expression()
	<RPAREN>
}

